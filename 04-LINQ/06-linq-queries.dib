#!markdown

# 4.6. LINQ queries

<small>Copyright (c) Mateusz Gienieczko 2022</small>

## How to use this notebook

### Content

This notebook is a part of the C#.NET Course at https://gienieczko.com/teaching/csharp/4-linq.

It covers topics for section [4.6. LINQ Queries](https://gienieczko.com/teaching/csharp/4-linq/6-linq-queries).

### Notebook flow

The content within a single subsection of this notebook is self-contained.
However, within a single subsection you need to execute snippets from top to bottom,
as the snippets below might use variables or types that are declared in the snippets above.

### Play around

You can edit the code parts freely and experiment with the language.
That's kind of the point of doing all this in notebooks.

#!markdown

## Processing sequences of data

OK, we're finally here. Time to introduce our new best friend.
Language Integrated Query, LINQ for short, allows us to use a common set of
ergonomic operations on streams of data. There are two applications of LINQ:

- operations on in-memory collections via the `IEnumerable<T>` interface, also called LINQ-to-objects;
- operations on external data sources via the `IQueryable<T>` interface.

In this section we cover LINQ-to-objects.

Not only that, but there are also two ways of using LINQ: fluent syntax and query syntax.
We'll start with fluent syntax, which is the core one, and show the query syntactic sugar later.

LINQ is all about defining extension methods on the aforementioned interfaces.
All of these extensions live in `System.Linq`, which is one of the implicit usings
enabled by default.

#!markdown

### Mapping with `Select`

```csharp
IEnumerable<TResult> Select<TSource, TResult>(this IEnumerable<TSource> sequence, Func<TSource, TResult> selector);
```

The basic operations is mapping a sequence to another sequence by performing
a transformation on each of the elements:

#!csharp

void PrintSequence<T>(IEnumerable<T> sequence)
{
    var @string = string.Join(", ", sequence);
    Console.WriteLine(@string);
}

IEnumerable<int> sequence = new int[] { 1, 2, 3, 4, 5 };
IEnumerable<int> squares = sequence.Select(x => x * x);

PrintSequence(sequence);
PrintSequence(squares);

#!markdown

The operation is non-destructive -- it creates a new sequence, but
leaves the original one intact.

#!markdown

### Filtering with `Where`

```csharp
IEnumerable<T> Where<T>(this IEnumerable<T> source, Func<T, bool> predicate);
```

Another basic building block -- filtering by a boolean predicate:

#!csharp

var sequence = new [] { 1, 2, 3, 4, 5 };
var odd = sequence.Where(x => x % 2 == 1);

PrintSequence(odd);

#!markdown

### Composition

This is where the fun begins. We can fluently compose different
LINQ operators to get a pipeline processing our data stream.

#!csharp

var sequence = new [] { 1, 2, 3, 4, 5 };

var result = sequence.Select(x => x * x)
                .Where(x => x < 20)
                .Select(x => x + 1);

PrintSequence(result);

#!markdown

## Deferred execution

#!markdown

## Summary

We've learnt how to define strongly typed function objects in C#.
We know that they can be generic, and that most of them are in some way
equivalent to `Action` and `Func`. We know that method group expressions
give us values of delegate types, and in the next section we will learn how to
produce delegate values more easily with lambda expressions.

#!markdown

## Next up:

Continue with the next section, [4.6. LINQ Queries](https://gienieczko.com/teaching/csharp/4-linq/6-linq-queries),
or straight to the next notebook, [`06-linq-queries.dib`](/04-LINQ/06-linq-queries.dib).
