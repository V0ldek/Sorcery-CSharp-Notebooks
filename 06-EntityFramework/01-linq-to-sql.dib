#!markdown

# 6.1. LINQ to SQL

<small>Copyright (c) Mateusz Gienieczko 2022</small>

## How to use this notebook

### Content

This notebook is a part of the C#.NET Course at https://gienieczko.com/teaching/csharp/6-entity-framework/1-linq-to-sql.

It covers topics for section [6.1. LINQ to SQL](https://gienieczko.com/teaching/csharp/6-entity-framework/1-linq-to-sql).

### Notebook flow

The content within a single subsection of this notebook is self-contained.
However, within a single subsection you need to execute snippets from top to bottom,
as the snippets below might use variables or types that are declared in the snippets above.

### Play around

You can edit the code parts freely and experiment with the language.
That's kind of the point of doing all this in notebooks.

#!markdown

## Setup

`IQueryProvider` is just an interface. We need something to actually provide the query capabilities. For LINQ-to-SQL we need **Entity Framework**.

Entity Framework is the flagship .NET ORM (object-relational-mapper). It's versioning is a bit confusing, the current version is `Entity Framework Core 6.0`. There is also `Entity Framework 6.0`, which is a completely different version for .NET Framework. We only care about Core versions.

To use it in the notebook we need a special spell that will load the library from NuGet.

#!csharp

#r "nuget:Microsoft.EntityFrameworkCore,6.0.4"

#!markdown

The core of the library is database-agnostic. However, to actually do anything we need a **database provider**.

There are providers for all conventional databases. To make our life easy, we will use [**SQLite**](https://sqlite.org/index.html) for the notebooks. It keeps the entire database as a file on your local system, requires no installation, and doesn't implement any flashy features, but gives us the standard SQL interface.

Each provider is a package, so we need the SQLite provider from NuGet:

#!csharp

#r "nuget:Microsoft.EntityFrameworkCore.Sqlite,6.0.4"

#!markdown

## Code First

There are two approaches to Entity Framework -- **Code First** and **Database First**. The latter is used when we want the database code to be the single-source-of-truth for our system. This is usually used when there already is a database that we want to build stuff on top, or if the database is the most important part of the system that will have many applications connecting to it. In that approach we tell EF where the database is and it creates a C# model for us from it.

Code First is what we will use. It allows us to have full control over the database from .NET. We define classes representing **entities** in our system first and generate the database schema from it. In this section we will define a very simple database with a single table.

#!csharp

public sealed class DungeonRun
{
    public int Id { get; private init; }

    public string HeroClass { get; private init; }

    public string DungeonName { get; private init; }

    public int RoomsCleared { get; private init; }

    public int DamageDealt { get; private init; }

    public DungeonRun(string heroClass, string dungeonName, int roomsCleared, int damageDealt) =>
        (HeroClass, DungeonName, RoomsCleared, DamageDealt) =
            (heroClass, dungeonName, roomsCleared, damageDealt);
}

#!markdown

The `private init` accessors are required for EF. It uses black magic to access these setters and assign values when mapping from the database to the class.

Now we need to define a model. This is done by defining a **database context**, which is a class extending the EF's `DbContext` base class. There are three important parts of a db context:

- The `DbSet`s, which define what sets of entities are available in the database; these map to individual tables in the database.
- `OnConfiguring`, which is used to configure the provider -- what provider to use, how to connect to the database, any database specific options to configure.
- `OnModelCreating`, which defines the model.

#!csharp

using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Sqlite;

public sealed class DungeonDbContext : DbContext
{
    public DbSet<DungeonRun> DungeonRuns { get; private init; }

    protected override void OnConfiguring(DbContextOptionsBuilder options)
    {
        options.UseSqlite("Data Source=./data/Dungeon.db");
    }

    protected override void OnModelCreating(ModelBuilder model)
    {
        var dungeonRun = model.Entity<DungeonRun>();

        dungeonRun.HasKey(d => d.Id);
        dungeonRun.ToTable("DungeonRun");
    }
}

#!markdown

### Migrations

Code First uses a concept called **migrations** to generate the database.
The schema of the database depends on the sequence of migrations, $\mu_1, \mu_2, \ldots, \mu_n$. Each migration
$\mu_i$ tells us how to bring the database from state $i$ **up** to state $i + 1$, and how to revert it to $i - 1$, with state $0$ being empty.

Generating migrations generally happens outside of code, via a CLI tool. One first needs to install the `dotnet-ef` tool and then run it to produce a `.cs` file with a migration:

```bash
dotnet tool install --global dotnet-ef

dotnet ef migrations add Initial
```

Then we can update the database either by generating an SQL script (or by directly connecting to the database via `dotnet ef database update`).

```bash
dotnet ef migrations script
```

Here's what EF generates for our simple context:

```csharp
public partial class Initial : Migration
{
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.CreateTable(
            name: "DungeonRun",
            columns: table => new
            {
                Id = table.Column<int>(type: "INTEGER", nullable: false)
                    .Annotation("Sqlite:Autoincrement", true),
                HeroClass = table.Column<string>(type: "TEXT", nullable: false),
                DungeonName = table.Column<string>(type: "TEXT", nullable: false),
                RoomsCleared = table.Column<int>(type: "INTEGER", nullable: false),
                DamageDealt = table.Column<int>(type: "INTEGER", nullable: false)
            },
            constraints: table =>
            {
                table.PrimaryKey("PK_DungeonRun", x => x.Id);
            });
    }

    protected override void Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropTable(
            name: "DungeonRun");
    }
}
```

And the script:

```sql
CREATE TABLE IF NOT EXISTS "__EFMigrationsHistory" (
    "MigrationId" TEXT NOT NULL CONSTRAINT "PK___EFMigrationsHistory" PRIMARY KEY,
    "ProductVersion" TEXT NOT NULL
);

BEGIN TRANSACTION;

CREATE TABLE "DungeonRun" (
    "Id" INTEGER NOT NULL CONSTRAINT "PK_DungeonRun" PRIMARY KEY AUTOINCREMENT,
    "HeroClass" TEXT NOT NULL,
    "DungeonName" TEXT NOT NULL,
    "RoomsCleared" INTEGER NOT NULL,
    "DamageDealt" INTEGER NOT NULL
);

INSERT INTO "__EFMigrationsHistory" ("MigrationId", "ProductVersion")
VALUES ('20220507094401_Initial', '6.0.4');

COMMIT;
```

#!markdown

In the notebooks we will use a less robust, but simpler approach.

#!csharp

var db = new DungeonDbContext();
db.Database.EnsureCreated();
await db.Database.MigrateAsync();

#!markdown

## Querying

We query the database by accessing a `DbSet<TEntity>`. This is the root object that implements `IQueryable<TEntity>` and starts the query chain.

#!csharp

async Task ListEntitiesAsync()
{
    await using var dbContext = new DungeonDbContext();

    Console.WriteLine("Entities:");
    foreach (var entity in await dbContext.DungeonRuns.ToListAsync())
    {
        Console.WriteLine($"[{entity.Id}]. {entity.HeroClass}, {entity.DungeonName}, üö™ {entity.RoomsCleared} ‚öîÔ∏è {entity.DamageDealt}");
    }
}

await ListEntitiesAsync();

#!markdown

Oh, right. We never added anything, well, let's!

#!csharp

async Task SeedDatabaseAsync()
{
    await using var dbContext = new DungeonDbContext();

    dbContext.DungeonRuns.Add(new("Warrior", "Magical Maze", 16, 180));
    dbContext.DungeonRuns.Add(new("Rogue", "Magical Maze", 14, 130));
    dbContext.DungeonRuns.Add(new("Wizard", "Magical Maze", 15, 150));
    dbContext.DungeonRuns.Add(new("Warrior", "Adventure", 10, 120));
    dbContext.DungeonRuns.Add(new("Rogue", "Adventure", 7, 69));
    dbContext.DungeonRuns.Add(new("Wizard", "Adventure", 7, 73));

    await dbContext.SaveChangesAsync();
}

await SeedDatabaseAsync();
await ListEntitiesAsync();

#!markdown

Now it works. And now we can _go to town_.

#!csharp

async Task DemoAsync()
{
    await using var dbContext = new DungeonDbContext();

    Console.WriteLine("Total damage dealt, by hero:");

    var totalDamageDealtByHero = dbContext.DungeonRuns
        .GroupBy(r => r.HeroClass)
        .Select(g => new { Hero = g.Key, Damage = g.Sum(r => r.DamageDealt) })
        .OrderByDescending(x => x.Damage);

    foreach (var entry in await totalDamageDealtByHero.ToListAsync())
    {
        Console.WriteLine($"{entry.Hero}: ‚öîÔ∏è {entry.Damage}");
    }

    Console.WriteLine("Lowest damage dealt in a run:");

    var lowestDamage = await dbContext.DungeonRuns.MinAsync(r => r.DamageDealt);

    Console.WriteLine($"‚öîÔ∏è {lowestDamage}");

    
}

await DemoAsync();

#!markdown

## Next up:

Continue with the next section, [6.1 LINQ to SQL](https://gienieczko.com/teaching/csharp/6-entity-framework/1-linq-to-sql),
or straight to the next notebook, [`06-entity-framework.dib`](01-linq-to-sql.dib).
