#!markdown

# 3.4. Equality

<small>Copyright (c) Mateusz Gienieczko 2022</small>

## How to use this notebook

### Content

This notebook is a part of the C#.NET Course at https://gienieczko.com/teaching/csharp/3-advanced-types.

It covers topics for section [3.4. Equality](https://gienieczko.com/teaching/csharp/3-advanced-types/4-equality).

### Notebook flow

The content within a single subsection of this notebook is self-contained.
However, within a single subsection you need to execute snippets from top to bottom,
as the snippets below might use variables or types that are declared in the snippets above.

### Play around

You can edit the code parts freely and experiment with the language.
That's kind of the point of doing all this in notebooks.

#!markdown

## Default equality

Since the `bool Equals(object)` method is defined on `object`, every pair of objects can be compared for equality.
Default equality semantics differ for reference and value types.
Reference types, by default, have **referential equality** â€“ two objects are equal iff they point to the exact
same object on the heap. The `Equals` method and `==` operator are exactly the same in this case.

#!csharp

class C
{
    public int Value { get; init; }
}

var c1 = new C { Value = 42 };
var c2 = new C { Value = 42 };

Console.WriteLine(c1.Equals(c2));
Console.WriteLine(c1.Equals(c1));
Console.WriteLine(c1 == c2);
Console.WriteLine(c1 == c1);

#!markdown

Value types on the other hand define **structural equality** by default.
They are equal if and only if all of their fields are equal.

_(This makes it a recursive definition, but that's fine since we cannot define a struct that contains itself in the first place)_

#!csharp

readonly struct Point
{
    public double X { get; init; }

    public double Y { get; init; }
}

readonly struct Triangle
{
    public Point A { get; init; }
    
    public Point B { get; init; }
    
    public Point C { get; init; }
}

var triangle = new Triangle
{
    A = new() { X = 17, Y = 42 },
    B = new() { X = -3, Y = 17 },
    C = new() { X = 2 },
};

var otherTriangle = new Triangle
{
    A = new() { X = 17, Y = 42 },
    B = new() { X = -3, Y = 17 },
    C = new() { X = 2 },
};

Console.WriteLine(triangle.Equals(otherTriangle));

#!markdown

The `==` operator is _not_ defined on structs by default:

#!csharp

// Intentionally does not compile.
triangle == otherTriangle

#!markdown

We came across a dichotomy here: `Equals` is not necessarily the same as `==`, and `==` doesn't even have to be defined.
To go further, we need to talk about operator overloading.

#!markdown

## Summary

#!markdown

## Next up:

Continue with the next section, [1.4. Nested Types](https://gienieczko.com/teaching/csharp/2-references-and-values/4-nested-types),
or straight to the next notebook, `04-nested-types.dib`.
